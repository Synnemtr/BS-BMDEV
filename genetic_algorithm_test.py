import random
import matplotlib.pyplot as plt
import numpy as np
from scipy.spatial import distance
import time
import itertools
from genetic_algorithm import genetic_algorithm_with_mse, genetic_algorithm_with_psnr, genetic_algorithm_with_ssim
from autoencoder import load_autoencoder_model, split_data

def population_initiation(batch, population_size):
    images, _ = next(batch)

    if population_size > len(images):
        print(f"Population size is greater than the number of images in the batch. Displaying {len(images)} images instead.")
        population_size = len(images)

    init_population = random.sample(list(images), population_size)
    return init_population

# Compare the average fitness scores of the final populations generated by each algorithm
# A higher fitness score indicates a better fit of the generated images to the original images
def compare_average_fitness_scores(algorithms, encoder, decoder, image_width, image_height, image_channels, batch, population_size, max_iterations, mutation_rate):
    population = population_initiation(batch, population_size)
    results = {}

    for algorithm in algorithms:
        fitness_scores = []
        for i in range(max_iterations):
            encoded_victim_choice = [encoder.predict(image.reshape(1, image_width, image_height, image_channels)) for image in population[:2]]
            encode_population = [encoder.predict(image.reshape(1, image_width, image_height, image_channels)) for image in population]
            new_population, fitness_score = algorithm(encode_population, encoded_victim_choice, population_size, mutation_rate)
            decoded_new_population = [decoder.predict(image[-1]) for image in new_population]
            population = decoded_new_population
            fitness_scores.append(fitness_score)

        # average fitness score
        avg_fitness_score = np.mean(fitness_scores)

        results[algorithm.__name__] = {
            'average_fitness_score': avg_fitness_score,
        }

    return results

def plot_average_fitness_scores(results):
    algorithms = list(results.keys())
    avg_fitness_scores = [results[algorithm]['average_fitness_score'] for algorithm in algorithms]

    plt.bar(algorithms, avg_fitness_scores)
    plt.xlabel('Algorithms')
    plt.ylabel('Average Fitness Score')
    plt.title('Average Fitness Score of Different Algorithms')
    plt.show()

# Compare the diversity of the solutions generated by each algorithm
# A higher diversity of solutions indicates that the algorithm is able to explore the search space more effectively 
def compare_diversity_of_solutions(algorithms, encoder, decoder, image_width, image_height, image_channels, batch, population_size, max_iterations, mutation_rate):
    population = population_initiation(batch, population_size)
    results = {}

    for algorithm in algorithms:
        for i in range(max_iterations):
            encoded_victim_choice = [encoder.predict(image.reshape(1, image_width, image_height, image_channels)) for image in population[:2]]
            encode_population = [encoder.predict(image.reshape(1, image_width, image_height, image_channels)) for image in population]
            new_population, fitness_score = algorithm(encode_population, encoded_victim_choice, population_size, mutation_rate)
            decoded_new_population = [decoder.predict(image[-1]) for image in new_population]
            population = decoded_new_population

        # error: a 2-dimentional array needs to be passed
        diversity = np.mean(distance.pdist(population))
        
        # Convert the 1D array to a 2D array with a single column
        # population_2d = np.expand_dims(population, axis=1)
        # diversity = np.mean(distance.pdist(population_2d))

        # or use itertools
        # diversity = np.mean([distance.euclidean(img1, img2) for img1, img2 in itertools.combinations(population, 2)])

        results[algorithm.__name__] = {
            'diversity_of_solutions': diversity,
        }

    return results

def plot_diversity_of_solutions(results):
    algorithms = list(results.keys())
    diversities = [results[algorithm]['diversity_of_solutions'] for algorithm in algorithms]

    plt.bar(algorithms, diversities)
    plt.xlabel('Algorithms')
    plt.ylabel('Diversity of Solutions')
    plt.title('Diversity of Solutions of Different Algorithms')
    plt.show()

# Compare the computational efficiency of the algorithms (time required to generate the final population)
# A more efficient algorithm is desired
def compare_computational_efficiency(algorithms, encoder, decoder, image_width, image_height, image_channels, batch, population_size, max_iterations, mutation_rate):
    population = population_initiation(batch, population_size)
    results = {}

    for algorithm in algorithms:
        start_time = time.time()
        for i in range(max_iterations):
            encoded_victim_choice = [encoder.predict(image.reshape(1, image_width, image_height, image_channels)) for image in population[:2]]
            encode_population = [encoder.predict(image.reshape(1, image_width, image_height, image_channels)) for image in population]
            new_population, fitness_score = algorithm(encode_population, encoded_victim_choice, population_size, mutation_rate)
            decoded_new_population = [decoder.predict(image[-1]) for image in new_population]
            population = decoded_new_population
        end_time = time.time()

        # Compute the computational efficiency
        computational_efficiency = end_time - start_time

        results[algorithm.__name__] = {
            'computational_efficiency': computational_efficiency,
        }

    return results

def plot_computational_efficiency(results):
    algorithms = list(results.keys())
    efficiencies = [results[algorithm]['computational_efficiency'] for algorithm in algorithms]

    plt.bar(algorithms, efficiencies)
    plt.xlabel('Algorithms')
    plt.ylabel('Computational Efficiency')
    plt.title('Computational Efficiency of Different Algorithms')
    plt.show()
    
# Compare the convergence speed of the algorithms (number of generations required to reach a certain fitness score) 
# A faster convergence speed is desired
def compare_convergence_speed(algorithms, encoder, decoder, image_width, image_height, image_channels, batch, population_size, max_iterations, mutation_rate, target_fitness_score):
    population = population_initiation(batch, population_size)
    results = {}

    for algorithm in algorithms:
        fitness_scores = []
        for i in range(max_iterations):
            encoded_victim_choice = [encoder.predict(image.reshape(1, image_width, image_height, image_channels)) for image in population[:2]]
            encode_population = [encoder.predict(image.reshape(1, image_width, image_height, image_channels)) for image in population]
            new_population, fitness_score = algorithm(encode_population, encoded_victim_choice, population_size, mutation_rate)
            decoded_new_population = [decoder.predict(image[-1]) for image in new_population]
            population = decoded_new_population
            fitness_scores.append(fitness_score)

            # Check if the target fitness score has been reached
            if fitness_score >= target_fitness_score:
                break

        # Compute the convergence speed
        convergence_speed = i + 1

        results[algorithm.__name__] = {
            'convergence_speed': convergence_speed,
        }

    return results
            

# Main function to run the program
if __name__ == "__main__":

    # Static parameters
    population_size = 4
    max_iterations = 3
    mutation_rate = 0.01
    image_width = 128
    image_height = 128
    image_channels = 3

    folder="./data/img_align_celeba"
    train_data, val_data=split_data(folder, seed_nb=40, image_size=(image_width,image_height), batch_size=128)
    # File hard-coded into the function
    autoencoder_loaded, encoder, decoder=load_autoencoder_model('model/test_model.keras')

    algorithms = [genetic_algorithm_with_mse, genetic_algorithm_with_psnr, genetic_algorithm_with_ssim]
    average_fitness_score = compare_average_fitness_scores(algorithms, encoder, decoder, image_width, image_height, image_channels, train_data, population_size, max_iterations, mutation_rate)
    diversity = compare_diversity_of_solutions(algorithms, encoder, decoder, image_width, image_height, image_channels, train_data, population_size, max_iterations, mutation_rate)
    computational_efficiency = compare_computational_efficiency(algorithms, encoder, decoder, image_width, image_height, image_channels, train_data, population_size, max_iterations, mutation_rate)
    plot_average_fitness_scores(average_fitness_score)
    plot_diversity_of_solutions(diversity)
    plot_computational_efficiency(computational_efficiency)
