import random
import matplotlib as plt
import numpy as np
from scipy.spatial import distance
import time
from genetic_algorithm import genetic_algorithm_with_mse, genetic_algorithm_with_psnr, genetic_algorithm_with_ssim
from autoencoder import load_autoencoder_model, split_data

def population_initiation(batch, population_size):
    images, _ = next(batch)

    if population_size > len(images):
        print(f"Population size is greater than the number of images in the batch. Displaying {len(images)} images instead.")
        population_size = len(images)

    init_population = random.sample(list(images), population_size)
    return init_population

# Compare the average fitness scores of the final populations generated by each algorithm
# A higher fitness score indicates a better fit of the generated images to the original images
def compare_average_fitness_scores(algorithms, encoder, decoder, image_width, image_height, image_channels, batch, population_size, max_iterations, mutation_rate):
    population = population_initiation(batch, population_size)
    results = {}

    for algorithm in algorithms:
        fitness_scores = []
        for i in range(max_iterations):
            encode_population = [encoder.predict(image.reshape(1, image_width, image_height, image_channels)) for image in population]
            new_population, fitness_score = algorithm(encode_population, population_size, mutation_rate)
            decoded_new_population = [decoder.predict(image[-1]) for image in new_population]
            population = decoded_new_population
            fitness_scores.append(fitness_score)

        # average fitness score
        avg_fitness_score = np.mean(fitness_scores)

        results[algorithm.__name__] = {
            'average_fitness_score': avg_fitness_score,
        }

    return results

# Compare the diversity of the solutions generated by each algorithm
# A higher diversity of solutions indicates that the algorithm is able to explore the search space more effectively 
def compare_diversity_of_solutions(algorithms, encoder, decoder, image_width, image_height, image_channels, batch, population_size, max_iterations, mutation_rate):
    population = population_initiation(batch, population_size)
    results = {}

    for algorithm in algorithms:
        for i in range(max_iterations):
            encode_population = [encoder.predict(image.reshape(1, image_width, image_height, image_channels)) for image in population]
            new_population, fitness_score = algorithm(encode_population, population_size, mutation_rate)
            decoded_new_population = [decoder.predict(image[-1]) for image in new_population]
            population = decoded_new_population

        # Compute the diversity of solutions
        diversity = np.mean(distance.pdist(np.array(population)))

        results[algorithm.__name__] = {
            'diversity_of_solutions': diversity,
        }

    return results

# Compare the computational efficiency of the algorithms (time required to generate the final population)
# A more efficient algorithm is desired
def compare_computational_efficiency(algorithms, encoder, decoder, image_width, image_height, image_channels, batch, population_size, max_iterations, mutation_rate):
    population = population_initiation(batch, population_size)
    results = {}

    for algorithm in algorithms:
        start_time = time.time()
        for i in range(max_iterations):
            encode_population = [encoder.predict(image.reshape(1, image_width, image_height, image_channels)) for image in population]
            new_population, fitness_score = algorithm(encode_population, population_size, mutation_rate)
            decoded_new_population = [decoder.predict(image[-1]) for image in new_population]
            population = decoded_new_population
        end_time = time.time()

        # Compute the computational efficiency
        computational_efficiency = end_time - start_time

        results[algorithm.__name__] = {
            'computational_efficiency': computational_efficiency,
        }

    return results
    
# Compare the convergence speed of the algorithms (number of generations required to reach a certain fitness score) 
# A faster convergence speed is desired
def compare_convergence_speed(algorithms, encoder, decoder, image_width, image_height, image_channels, batch, population_size, max_iterations, mutation_rate, target_fitness_score):
    population = population_initiation(batch, population_size)
    results = {}

    for algorithm in algorithms:
        fitness_scores = []
        for i in range(max_iterations):
            encode_population = [encoder.predict(image.reshape(1, image_width, image_height, image_channels)) for image in population]
            new_population, fitness_score = algorithm(encode_population, population_size, mutation_rate)
            decoded_new_population = [decoder.predict(image[-1]) for image in new_population]
            population = decoded_new_population
            fitness_scores.append(fitness_score)

            # Check if the target fitness score has been reached
            if fitness_score >= target_fitness_score:
                break

        # Compute the convergence speed
        convergence_speed = i + 1

        results[algorithm.__name__] = {
            'convergence_speed': convergence_speed,
        }

    return results
            

# Main function to run the program
if __name__ == "__main__":

    # Static parameters
    population_size = 4
    max_iterations = 10
    mutation_rate = 0.01
    image_width = 128
    image_height = 128
    image_channels = 3

    folder="./data/img_align_celeba"
    train_data, val_data=split_data(folder, seed_nb=40, image_size=(image_width,image_height), batch_size=128)
    # File hard-coded into the function
    autoencoder_loaded, encoder, decoder=load_autoencoder_model('model/test_model.keras')

    algorithms = [genetic_algorithm_with_mse, genetic_algorithm_with_psnr, genetic_algorithm_with_ssim]
    avg_fitness_scores = compare_average_fitness_scores(algorithms, encoder, decoder, image_width, image_height, image_channels, train_data, population_size, max_iterations, mutation_rate)
    diversity_of_solutions = compare_diversity_of_solutions(algorithms, encoder, decoder, image_width, image_height, image_channels, train_data, population_size, max_iterations, mutation_rate)
    computational_efficiency = compare_computational_efficiency(algorithms, encoder, decoder, image_width, image_height, image_channels, train_data, population_size, max_iterations, mutation_rate)

    # display the results
    fig, axs = plt.subplots(3, 1, figsize=(10, 15))

    axs[0].bar(avg_fitness_scores.keys(), [v['average_fitness_score'] for v in avg_fitness_scores.values()])
    axs[0].set_title('Average Fitness Scores')
    axs[0].set_ylabel('Fitness Score')

    axs[1].bar(diversity_of_solutions.keys(), [v['diversity_of_solutions'] for v in diversity_of_solutions.values()])
    axs[1].set_title('Diversity of Solutions')
    axs[1].set_ylabel('Diversity')

    axs[2].bar(computational_efficiency.keys(), [v['computational_efficiency'] for v in computational_efficiency.values()])
    axs[2].set_title('Computational Efficiency')
    axs[2].set_ylabel('Time (seconds)')

    plt.tight_layout()
    plt.show()